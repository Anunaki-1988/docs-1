## Installation
The OpenML website runs on [Flask](http://flask.pocoo.org/) and [React](https://reactjs.org/). You need to install these first

If you haven't already, install a recent version of NPM (6 or higher).

Next, due to a recent bad webpack update, install the following:
``` python
npm install webpack@^4.20.2 webpack-cli@^3.1.1
```

Build the app by running

``` python
npm run build
```

Install Flask with `pip install Flask`. Start the service with:

``` python
python server.py
```

You should now see it running in your browser at `localhost:5000`

## Development

To start the React frontend in developer mode (with hot loading), run:

``` python
npm run dev
```

The app should automatically open at `localhost:8080` and any changes made to
the code will automatically reload the website.

## Structure
![OpenML Website structure](../img/structure.png)

The website is built on the following components:  
* A Flask backend. Written in Python, the backend takes care of all communication with the OpenML server. It builds on top of the OpenML Python API. It also takes care of user authentication and keeps the search engine (ElasticSearch) up to date with the latest information from the server.
* A React frontend. Written in JavaScript, this takes care of rendering the website. It pulls in information from the search engine, and shows plots rendered by Dash. It also contains forms (e.g. for logging in or uploading new datasets), which will be sent off to the backend for processing.
* Dash dashboards. Written in Python, Dash is used for writing interactive plots. It pulls in data from the Python API, and renders the plots as React components.


## Flask (backend)
We use [Flask](http://flask.pocoo.org/) as our web framework. It handles user
authentication, dataset upload, task creation, and other aspects that require
server-side interaction. It is designed to be _independent_ from the OpenML API.
This means that you can use it to create your own personal frontend for OpenML,
using the main OpenML server to provide the data. Of course, you can also link
it to your own [local OpenML setup](Local-Installation).

### Bindings to OpenML server
You can specify which OpenML server to connect to.
This is stored in the `.env` file in the main directory. It is set to the main OpenML server by default:

``` python
    ELASTICSEARCH_SERVER=https://www.openml.org/es
    OPENML_SERVER=https://www.openml.org
```

The ElasticSearch server is used to download information about datasets, tasks, flows and runs, as well as to power the frontend search. The OpenML server is used for uploading datasets, tasks, and anything else that requires calls to the OpenML API.

### Bindings to frontend
The frontend is generated by [React](https://reactjs.org/). See below for more information. The React app is loaded as a static website. This is done in Flask setup in file `server.py`.

``` python
    app = Flask(__name__, static_url_path='', static_folder='src/client')
```

We use webpack to bundle the whole React App into one file `bundle.js`. This is done by running `npm run debug`. The settings for this are in `webpack.config.js`. For instance, it defines that `client/app/openml.jsx` is the entry file for the web app.

``` python
entry: APP_DIR + '/openml.jsx',
```

It will find the React app there and load it.

## React (frontend)
### React components


### Handling state
We manage state through React Context. The state of parent components is automatically inherited by child components.

Authentication information in stored in the `AuthProvider` component.

### Styling
To keep a consistent style and minimize dependencies and complexity, we build on [Material UI](https://material-ui.com/). Overall theming is defined in the parent component `openml.jsx`. Additional styling is defined in the subcomponents themselves.

### React Basics
Here are a few React basics you need to know about when developing the frontend. If you've developed with React before, this will just jog your memory. If you are completely new to React, we recommend 'The Road to learn React' by Robin Wieruch.

#### Components
React only builds the 'View' layer of a web application, depending on APIs to receive information from a backend. The view is a hierarchy of composable _components_, each isolating all the code for rendering a specific part ('box') of the user interface. This is encapsulated in the `render()` method, which renders the component every time something changes. This method returns JSX syntax, a mix of HTML and javascript that allows easy templating. The curly braces {} tell the JSX parser that it needs to interpret the contents. JSX supports most HTML attributes, although some are renamed. For instance, `className` replaces the standard HTML `class` attribute.

Components are usually defined as subclasses of React.Component. Here we define a simple 'App' component:
``` javascript
class App extends Component {
  render() {
    const title = "Welcome to OpenML";
    return (
    <div className="App">
      <h1>{title}</h1>
    </div>
    );
  }
}
```

Components can have multiple child components, which are instantiated inside the parent's render method:
Here's a simple example:
``` javascript
class App extends Component {
  render() {
    return (
    // This instantiates a component of class TitleBar
    <TitleBar />
    <MainComponent />
    );
  }
}
```

We can replace any HTML element with a React component (and all its children). Often, we will simply replace the whole HTML root:
``` javascript
ReactDOM.render(
  <App />,
  document.getElementById('root')
);
```

#### Component state
React components have internal properties and state that can be accessed though the `props` and `state` data structures. `state` stores the data that you need to render the component. It is mutable (via `setState()`) and can be changed asynchronously. It holds anything that can be changed by the component itself. It should not be accessed by child or parent components (consider it private). `props` contains your component's fixed properties (configuration). It is immutable by the component itself, only by its parent. It is used to pass data (and event handlers) from a parent component to a child component. Every time that `props` or `state` change, the component will re-render.

Here is an example of a simple component that changes its own state through a button click.
``` javascript
const titles: {mainTitle: 'OpenML'};

class App extends Component {
  constructor(props){
    super(props); // required
  }
  // State initialization
  // Shorthand for this.state = {titles: titles};
  this.state = {titles};

  // Methods need to be bound to the class to have access to `this`.
  // Arrow functions are automatically bound
  changeMainTitle = (name) => {
    this.setState({titles.mainTitle : name});
  }

  render(){
    return (
      <div classname="App">
        <h1>{this.state.titles.mainTitle}</h1>
        <button type="button"
          //Arrow function passed to onClick event handler
          onClick={() => this.changeMainTitle("NewOpenML")}
          > Update
        </button>
      </div>
    );
  }
}
```

Here is an example of component state being passed on to child components via properties.
Optionally, the `children` prop can be used to pass elements to child components, such as a text string here.
``` javascript
class App extends Component {
  ...
  render(){
    return (
      <div classname="App">
        // Creates a new TitleBar component with a property `title`
        <TitleBar
          title={this.state.titles.mainTitle}
        > Subtext
        </TitleBar>
        <Content />
      </div>
    );
  }
}
class TitleBar extends Component {
  render(){
    // Unpacking (deconstructing) the properties
    const {myTitle, children} = this.props;
    return (
      <h1>{myTitle}</h1>
      {children}
    );
  }
}
```



#### Forms and Events
React wraps native browser events into _synthetic events_ to handle interactions in a cross-browser compatible way. After being wrapped, they are sent to
all event handlers, usually defined as callbacks. Note: for performance reasons, synthetic events are pooled and reused, so their properties are nullified after being consumed. If you want to use them asynchronously, you need to call `event.persist()`.

HTML forms are different than other DOM elements because they keep their own state in plain HTML. To make sure that we can control the state
we need to set the input field's `value` to a component state value.

Here's an example of using an input field to change the title displayed in the component.
``` javascript
const titles: {mainTitle: 'OpenML'};

class App extends Component {
  this.state = {titles};

  // Receive synthetic event
  onTitleChange = (event) => {
    this.setState({titles.mainTitle : event.target.value});
  }

  render(){
    return (      
      <div classname="App">
        <h1>{this.state.titles.mainTitle}</h1>
        <form>
          <input type="text"
          value={this.state.titles.mainTitle} // control state
          onChange={this.onTitleChange} // event handler callback
          />
        </form>
      </div>
    );
  }
}
```

#### Component declarations



## Dash (visualization)
TODO
